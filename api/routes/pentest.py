"""
Router para Pentesting Aut칩nomo (v4.5.0)
Refactorizado para usar arquitectura modular: Planner -> Validator -> Executor -> Report
"""

import logging
import uuid
from pathlib import Path
from fastapi import APIRouter, BackgroundTasks, HTTPException
from pydantic import BaseModel
from api.config import settings
from api.models.pentest import (
    PentestRequest, 
    PentestPlan, 
    ApprovalRequest,
    PentestPolicy
)
from api.services.pentest_policy import get_active_policy, update_case_policy
from api.services.pentest_planner import generate_pentest_plan
from api.services.pentest_validator import validate_plan
from api.services.pentest_executor import get_executor
from api.services.pentest_report import generate_pentest_report

router = APIRouter(prefix="/pentest", tags=["pentest"])
logger = logging.getLogger(__name__)


async def _run_pentest_workflow(
    pentest_id: str,
    case_id: str,
    plan: PentestPlan,
    evidence_path: Path
):
    """
    Workflow completo en background:
    Execute -> Report
    """
    executor = get_executor()
    try:
        logger.info(f"游 Iniciando ejecuci칩n de pentest {pentest_id}")
        completed, failed = await executor.execute_plan(
            pentest_id, 
            case_id, 
            plan, 
            evidence_path
        )
        
        # Generar reporte final
        generate_pentest_report(
            pentest_id,
            case_id,
            completed,
            failed,
            evidence_path
        )
        logger.info(f"游끠 Pentest {pentest_id} finalizado")
        
    except Exception as e:
        logger.error(f"游눤 Error cr칤tico en workflow de pentest {pentest_id}: {e}", exc_info=True)


@router.post("/start", response_model=PentestPlan)
async def start_pentest(
    request: PentestRequest,
    background_tasks: BackgroundTasks
):
    """
    Inicia un pentest aut칩nomo.
    1. Obtiene pol칤tica
    2. Genera plan con LLM
    3. Valida plan contra pol칤tica
    4. Inicia ejecuci칩n en background
    """
    pentest_id = f"PT-{uuid.uuid4().hex[:8]}"
    logger.info(f"游 Solicitud de pentest {pentest_id} para caso {request.case_id}")
    
    # 1. Obtener pol칤tica
    policy = get_active_policy(request.case_id)
    
    # 2. Generar plan (LLM)
    plan = await generate_pentest_plan(request, policy)
    plan.pentest_id = pentest_id  # Asignar ID generado
    
    # 3. Validar plan
    plan = validate_plan(plan, policy)
    
    # Preparar directorio de evidencia
    evidence_path = settings.EVIDENCE_DIR / request.case_id / "pentest" / pentest_id
    evidence_path.mkdir(parents=True, exist_ok=True)
    
    # 4. Ejecutar en background
    background_tasks.add_task(
        _run_pentest_workflow,
        pentest_id,
        request.case_id,
        plan,
        evidence_path
    )
    
    return plan


@router.post("/approve")
async def approve_task(request: ApprovalRequest):
    """
    Aprueba una tarea bloqueada por pol칤tica.
    """
    executor = get_executor()
    logger.info(f"游댑 Aprobando tarea {request.task_id} para pentest {request.pentest_id}")
    
    try:
        executor.approve_task(request.pentest_id, request.task_id)
        return {"status": "approved", "task_id": request.task_id}
    except Exception as e:
        logger.error(f"Error aprobando tarea: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/policy/{case_id}", response_model=PentestPolicy)
async def get_policy(case_id: str):
    """Obtiene la pol칤tica activa para un caso"""
    return get_active_policy(case_id)


@router.put("/policy/{case_id}", response_model=PentestPolicy)
async def update_policy(case_id: str, policy: PentestPolicy):
    """Actualiza la pol칤tica de un caso"""
    if policy.case_id != case_id:
        raise HTTPException(status_code=400, detail="Case ID mismatch")
    
    return update_case_policy(policy)


class BreakGlassRequest(BaseModel):
    justification: str


@router.post("/policy/{case_id}/break-glass", response_model=PentestPolicy)
async def enable_break_glass(case_id: str, request: BreakGlassRequest):
    """
    Activa el modo 'Break Glass' para permitir acciones prohibidas.
    Requiere justificaci칩n expl칤cita.
    """
    policy = get_active_policy(case_id)
    policy.break_glass_mode = True
    policy.break_glass_justification = request.justification
    
    logger.warning(f"游뚿 BREAK GLASS ACTIVADO para caso {case_id}. Justificaci칩n: {request.justification}")
    
    return update_case_policy(policy)
