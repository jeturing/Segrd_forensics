"""
Multi-Language Report Generator
Genera reportes forenses en InglÃ©s, EspaÃ±ol, CantonÃ©s y Chino Simplificado
"""

from typing import Dict, Optional, Literal
from datetime import datetime
from pathlib import Path
import json
from jinja2 import Environment, FileSystemLoader
import logging

logger = logging.getLogger(__name__)

# Traducciones para reportes
TRANSLATIONS = {
    "en": {
        "report_title": "Forensic Investigation Report",
        "case_id": "Case ID",
        "investigation_date": "Investigation Date",
        "executive_summary": "Executive Summary",
        "findings": "Findings",
        "recommendations": "Recommendations",
        "evidence": "Evidence",
        "timeline": "Timeline",
        "iocs": "Indicators of Compromise",
        "threat_actors": "Threat Actors",
        "mitigation": "Mitigation Steps",
        "risk_level": "Risk Level",
        "critical": "Critical",
        "high": "High",
        "medium": "Medium",
        "low": "Low",
        "tools_used": "Tools Used",
        "m365_analysis": "Microsoft 365 Analysis",
        "azure_ad": "Azure Active Directory",
        "compromised_users": "Compromised Users",
        "suspicious_signins": "Suspicious Sign-ins",
        "malicious_apps": "Malicious Applications",
        "data_exfiltration": "Data Exfiltration",
        "privilege_escalation": "Privilege Escalation",
        "generated_by": "Generated by",
        "confidential": "CONFIDENTIAL - DO NOT DISTRIBUTE"
    },
    "es": {
        "report_title": "Reporte de InvestigaciÃ³n Forense",
        "case_id": "ID del Caso",
        "investigation_date": "Fecha de InvestigaciÃ³n",
        "executive_summary": "Resumen Ejecutivo",
        "findings": "Hallazgos",
        "recommendations": "Recomendaciones",
        "evidence": "Evidencia",
        "timeline": "LÃ­nea de Tiempo",
        "iocs": "Indicadores de Compromiso",
        "threat_actors": "Actores de Amenaza",
        "mitigation": "Pasos de MitigaciÃ³n",
        "risk_level": "Nivel de Riesgo",
        "critical": "CrÃ­tico",
        "high": "Alto",
        "medium": "Medio",
        "low": "Bajo",
        "tools_used": "Herramientas Utilizadas",
        "m365_analysis": "AnÃ¡lisis de Microsoft 365",
        "azure_ad": "Azure Active Directory",
        "compromised_users": "Usuarios Comprometidos",
        "suspicious_signins": "Inicios de SesiÃ³n Sospechosos",
        "malicious_apps": "Aplicaciones Maliciosas",
        "data_exfiltration": "ExfiltraciÃ³n de Datos",
        "privilege_escalation": "EscalaciÃ³n de Privilegios",
        "generated_by": "Generado por",
        "confidential": "CONFIDENCIAL - NO DISTRIBUIR"
    },
    "zh-CN": {  # Chino Simplificado
        "report_title": "å–è¯è°ƒæŸ¥æŠ¥å‘Š",
        "case_id": "æ¡ˆä¾‹ç¼–å·",
        "investigation_date": "è°ƒæŸ¥æ—¥æœŸ",
        "executive_summary": "æ‰§è¡Œæ‘˜è¦",
        "findings": "è°ƒæŸ¥ç»“æžœ",
        "recommendations": "å»ºè®®",
        "evidence": "è¯æ®",
        "timeline": "æ—¶é—´çº¿",
        "iocs": "å…¥ä¾µæŒ‡æ ‡",
        "threat_actors": "å¨èƒè¡Œä¸ºè€…",
        "mitigation": "ç¼“è§£æ­¥éª¤",
        "risk_level": "é£Žé™©ç­‰çº§",
        "critical": "ä¸¥é‡",
        "high": "é«˜",
        "medium": "ä¸­",
        "low": "ä½Ž",
        "tools_used": "ä½¿ç”¨çš„å·¥å…·",
        "m365_analysis": "Microsoft 365 åˆ†æž",
        "azure_ad": "Azure Active Directory",
        "compromised_users": "å—æŸç”¨æˆ·",
        "suspicious_signins": "å¯ç–‘ç™»å½•",
        "malicious_apps": "æ¶æ„åº”ç”¨ç¨‹åº",
        "data_exfiltration": "æ•°æ®æ³„éœ²",
        "privilege_escalation": "æƒé™æå‡",
        "generated_by": "ç”Ÿæˆè€…",
        "confidential": "æœºå¯† - è¯·å‹¿åˆ†å‘"
    },
    "zh-HK": {  # CantonÃ©s (Chino Tradicional)
        "report_title": "å–è­‰èª¿æŸ¥å ±å‘Š",
        "case_id": "æ¡ˆä¾‹ç·¨è™Ÿ",
        "investigation_date": "èª¿æŸ¥æ—¥æœŸ",
        "executive_summary": "åŸ·è¡Œæ‘˜è¦",
        "findings": "èª¿æŸ¥çµæžœ",
        "recommendations": "å»ºè­°",
        "evidence": "è­‰æ“š",
        "timeline": "æ™‚é–“ç·š",
        "iocs": "å…¥ä¾µæŒ‡æ¨™",
        "threat_actors": "å¨è„…è¡Œç‚ºè€…",
        "mitigation": "ç·©è§£æ­¥é©Ÿ",
        "risk_level": "é¢¨éšªç­‰ç´š",
        "critical": "åš´é‡",
        "high": "é«˜",
        "medium": "ä¸­",
        "low": "ä½Ž",
        "tools_used": "ä½¿ç”¨çš„å·¥å…·",
        "m365_analysis": "Microsoft 365 åˆ†æž",
        "azure_ad": "Azure Active Directory",
        "compromised_users": "å—æç”¨æˆ¶",
        "suspicious_signins": "å¯ç–‘ç™»éŒ„",
        "malicious_apps": "æƒ¡æ„æ‡‰ç”¨ç¨‹å¼",
        "data_exfiltration": "æ•¸æ“šæ´©éœ²",
        "privilege_escalation": "æ¬Šé™æå‡",
        "generated_by": "ç”Ÿæˆè€…",
        "confidential": "æ©Ÿå¯† - è«‹å‹¿åˆ†ç™¼"
    }
}


class ReportGenerator:
    """Generador de reportes multiidioma"""
    
    def __init__(self, templates_dir: Optional[Path] = None):
        self.templates_dir = templates_dir or Path(__file__).parent.parent / "templates" / "reports"
        self.templates_dir.mkdir(parents=True, exist_ok=True)
        
        # Configurar Jinja2 - auto_reload=True para evitar problemas de cache
        self.jinja_env = Environment(
            loader=FileSystemLoader(str(self.templates_dir)),
            auto_reload=True
        )
    
    def translate(self, key: str, language: str = "en") -> str:
        """Obtiene traducciÃ³n para una clave"""
        return TRANSLATIONS.get(language, TRANSLATIONS["en"]).get(key, key)
    
    async def generate_investigation_report(
        self,
        investigation_id: str,
        investigation_data: Dict,
        language: Literal["en", "es", "zh-CN", "zh-HK"] = "en",
        format: Literal["html", "pdf", "json", "markdown"] = "html"
    ) -> Dict:
        """
        Genera reporte completo de investigaciÃ³n
        
        Args:
            investigation_id: ID de la investigaciÃ³n
            investigation_data: Datos de la investigaciÃ³n (casos, IOCs, timeline, etc)
            language: Idioma del reporte (en, es, zh-CN, zh-HK)
            format: Formato del reporte (html, pdf, json, markdown)
        
        Returns:
            Dict con path del reporte y metadata
        """
        try:
            logger.info(f"ðŸ“„ Generando reporte {language} para investigaciÃ³n {investigation_id}")
            
            # Preparar datos traducidos
            report_data = self._prepare_report_data(investigation_data, language)
            
            # Debug: verificar estructura de sections
            sections = report_data.get("sections", {})
            findings = sections.get("findings", {})
            logger.debug(f"ðŸ” Debug - sections.findings type: {type(findings)}, items type: {type(findings.get('items', []))}")
            
            # Generar segÃºn formato
            if format == "html":
                output_path = await self._generate_html_report(investigation_id, report_data, language)
            elif format == "pdf":
                output_path = await self._generate_pdf_report(investigation_id, report_data, language)
            elif format == "json":
                output_path = await self._generate_json_report(investigation_id, report_data, language)
            elif format == "markdown":
                output_path = await self._generate_markdown_report(investigation_id, report_data, language)
            else:
                raise ValueError(f"Formato no soportado: {format}")
            
            logger.info(f"âœ… Reporte generado: {output_path}")
            
            return {
                "investigation_id": investigation_id,
                "language": language,
                "format": format,
                "file_path": str(output_path),
                "generated_at": datetime.utcnow().isoformat(),
                "file_size_bytes": output_path.stat().st_size if output_path.exists() else 0
            }
            
        except Exception as e:
            logger.error(f"âŒ Error generando reporte: {e}", exc_info=True)
            raise
    
    def _prepare_report_data(self, investigation_data: Dict, language: str) -> Dict:
        """Prepara datos con traducciones"""
        
        t = lambda key: self.translate(key, language)
        
        return {
            "title": t("report_title"),
            "case_id": investigation_data.get("case_id", "N/A"),
            "investigation_date": datetime.utcnow().strftime("%Y-%m-%d %H:%M UTC"),
            "language": language,
            
            # Secciones traducidas - uso "entries" en lugar de "items" para evitar conflicto con dict.items()
            "sections": {
                "executive_summary": {
                    "title": t("executive_summary"),
                    "content": investigation_data.get("summary", {})
                },
                "findings": {
                    "title": t("findings"),
                    "entries": investigation_data.get("findings", [])
                },
                "iocs": {
                    "title": t("iocs"),
                    "entries": investigation_data.get("iocs", [])
                },
                "timeline": {
                    "title": t("timeline"),
                    "events": investigation_data.get("timeline", [])
                },
                "recommendations": {
                    "title": t("recommendations"),
                    "entries": investigation_data.get("recommendations", [])
                }
            },
            
            # Metadata
            "metadata": {
                "tools_used": investigation_data.get("tools_used", []),
                "risk_level": investigation_data.get("risk_level", "medium"),
                "analyst": investigation_data.get("analyst", "JETURING Forensics"),
                "confidential": t("confidential")
            },
            
            # M365 especÃ­fico
            "m365_data": investigation_data.get("m365_results", {}),
            
            # Traducir labels
            "labels": {
                key: t(key) for key in [
                    "case_id", "investigation_date", "risk_level", "tools_used",
                    "critical", "high", "medium", "low", "generated_by"
                ]
            }
        }
    
    async def _generate_html_report(self, investigation_id: str, data: Dict, language: str) -> Path:
        """Genera reporte HTML"""
        
        # Template HTML
        html_template = """
<!DOCTYPE html>
<html lang="{{ language }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }} - {{ case_id }}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Arial, sans-serif; 
            line-height: 1.6; 
            color: #333; 
            background: #f5f5f5;
            padding: 20px;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        .header { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header .confidential { 
            background: rgba(255,0,0,0.8);
            padding: 10px 20px;
            display: inline-block;
            margin-top: 20px;
            font-weight: bold;
            border-radius: 5px;
        }
        .content { padding: 40px; }
        .section { margin-bottom: 40px; }
        .section h2 { 
            color: #667eea;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .risk-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .risk-critical { background: #dc3545; color: white; }
        .risk-high { background: #fd7e14; color: white; }
        .risk-medium { background: #ffc107; color: black; }
        .risk-low { background: #28a745; color: white; }
        .finding-item { 
            background: #f8f9fa;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
            border-radius: 4px;
        }
        .ioc-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .ioc-table th, .ioc-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        .ioc-table th {
            background: #667eea;
            color: white;
        }
        .footer {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        .metadata { 
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .metadata-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }
        .metadata-item strong { display: block; color: #667eea; margin-bottom: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>{{ title }}</h1>
            <p style="font-size: 1.2em; margin-top: 10px;">{{ labels.case_id }}: {{ case_id }}</p>
            <p>{{ labels.investigation_date }}: {{ investigation_date }}</p>
            <div class="confidential">{{ metadata.confidential }}</div>
        </div>
        
        <div class="content">
            <!-- Metadata -->
            <div class="metadata">
                <div class="metadata-item">
                    <strong>{{ labels.risk_level }}</strong>
                    <span class="risk-badge risk-{{ metadata.risk_level }}">
                        {{ metadata.risk_level | default('medium') | upper }}
                    </span>
                </div>
                <div class="metadata-item">
                    <strong>{{ labels.generated_by }}</strong>
                    {{ metadata.analyst }}
                </div>
                <div class="metadata-item">
                    <strong>{{ labels.tools_used }}</strong>
                    {% if metadata.tools_used and metadata.tools_used is sequence and metadata.tools_used is not string and metadata.tools_used | length > 0 %}
                        {{ metadata.tools_used | join(', ') }}
                    {% else %}
                        N/A
                    {% endif %}
                </div>
            </div>
            
            <!-- Executive Summary -->
            <div class="section">
                <h2>{{ sections.executive_summary.title }}</h2>
                <div class="finding-item">
                    {% if sections.executive_summary.content is string %}
                        <p>{{ sections.executive_summary.content }}</p>
                    {% else %}
                        <pre style="white-space: pre-wrap;">{{ sections.executive_summary.content | tojson }}</pre>
                    {% endif %}
                </div>
            </div>
            
            <!-- Findings -->
            <div class="section">
                <h2>{{ sections.findings.title }}</h2>
                {% for finding in sections.findings.entries %}
                <div class="finding-item">
                    <strong>{{ finding.title }}</strong>
                    <p>{{ finding.description }}</p>
                    <small style="color: #666;">{{ finding.timestamp }}</small>
                </div>
                {% endfor %}
            </div>
            
            <!-- IOCs -->
            <div class="section">
                <h2>{{ sections.iocs.title }}</h2>
                <table class="ioc-table">
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Value</th>
                            <th>Severity</th>
                            <th>Source</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for ioc in sections.iocs.entries %}
                        <tr>
                            <td>{{ ioc.type }}</td>
                            <td><code>{{ ioc.value }}</code></td>
                            <td><span class="risk-badge risk-{{ ioc.severity }}">{{ ioc.severity }}</span></td>
                            <td>{{ ioc.source }}</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
            
            <!-- Timeline -->
            <div class="section">
                <h2>{{ sections.timeline.title }}</h2>
                {% for event in sections.timeline.events %}
                <div class="finding-item">
                    <strong>{{ event.timestamp }}</strong> - {{ event.description }}
                </div>
                {% endfor %}
            </div>
            
            <!-- Recommendations -->
            <div class="section">
                <h2>{{ sections.recommendations.title }}</h2>
                <ul>
                    {% for rec in sections.recommendations.entries %}
                    <li style="margin: 10px 0;">{{ rec }}</li>
                    {% endfor %}
                </ul>
            </div>
        </div>
        
        <div class="footer">
            <p><strong>JETURING Forensics Platform</strong></p>
            <p>{{ investigation_date }}</p>
        </div>
    </div>
</body>
</html>
        """
        
        # Guardar template
        template_file = self.templates_dir / "investigation_report.html"
        template_file.write_text(html_template)
        
        # Renderizar
        template = self.jinja_env.get_template("investigation_report.html")
        html_content = template.render(**data)
        
        # Guardar reporte
        output_path = Path(f"/tmp/reports/{investigation_id}_{language}.html")
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(html_content, encoding="utf-8")
        
        return output_path
    
    async def _generate_pdf_report(self, investigation_id: str, data: Dict, language: str) -> Path:
        """Genera reporte PDF (requiere wkhtmltopdf o similar)"""
        # Primero generar HTML
        html_path = await self._generate_html_report(investigation_id, data, language)
        
        # Convertir a PDF
        output_path = Path(f"/tmp/reports/{investigation_id}_{language}.pdf")
        
        try:
            import subprocess
            subprocess.run([
                "wkhtmltopdf",
                str(html_path),
                str(output_path)
            ], check=True)
        except Exception as e:
            logger.warning(f"No se pudo convertir a PDF: {e}. Devolviendo HTML.")
            return html_path
        
        return output_path
    
    async def _generate_json_report(self, investigation_id: str, data: Dict, language: str) -> Path:
        """Genera reporte JSON estructurado"""
        output_path = Path(f"/tmp/reports/{investigation_id}_{language}.json")
        output_path.parent.mkdir(parents=True, exist_ok=True)
        
        output_path.write_text(json.dumps(data, indent=2, ensure_ascii=False), encoding="utf-8")
        return output_path
    
    async def _generate_markdown_report(self, investigation_id: str, data: Dict, language: str) -> Path:
        """Genera reporte Markdown"""
        
        md_content = f"""# {data['title']}

**{data['labels']['case_id']}:** {data['case_id']}  
**{data['labels']['investigation_date']}:** {data['investigation_date']}  
**{data['labels']['risk_level']}:** {data['metadata']['risk_level'].upper()}

---

## {data['sections']['executive_summary']['title']}

{json.dumps(data['sections']['executive_summary']['content'], indent=2)}

## {data['sections']['findings']['title']}

"""
        
        for finding in data['sections']['findings']['items']:
            md_content += f"### {finding.get('title', 'Finding')}\n\n"
            md_content += f"{finding.get('description', '')}\n\n"
        
        md_content += f"## {data['sections']['iocs']['title']}\n\n"
        md_content += "| Type | Value | Severity | Source |\n"
        md_content += "|------|-------|----------|--------|\n"
        
        for ioc in data['sections']['iocs']['items']:
            md_content += f"| {ioc.get('type', '')} | `{ioc.get('value', '')}` | {ioc.get('severity', '')} | {ioc.get('source', '')} |\n"
        
        md_content += f"\n## {data['sections']['recommendations']['title']}\n\n"
        for i, rec in enumerate(data['sections']['recommendations']['items'], 1):
            md_content += f"{i}. {rec}\n"
        
        md_content += f"\n---\n\n*{data['metadata']['confidential']}*\n"
        
        output_path = Path(f"/tmp/reports/{investigation_id}_{language}.md")
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(md_content, encoding="utf-8")
        
        return output_path


# Instancia global
report_generator = ReportGenerator()
