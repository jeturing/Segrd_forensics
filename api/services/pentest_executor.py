"""
Pentest Executor â€” Ejecuta plan con sandbox y timeouts
Maneja approval gate, persiste evidencia
"""

import asyncio
import logging
import time
from pathlib import Path
from typing import Dict, List
from api.services.executor_engine import ToolExecutor
from api.models.pentest import PentestPlan, PentestTaskResult

logger = logging.getLogger(__name__)


class PentestExecutor:
    """Ejecutor de tareas con approval gate"""
    
    def __init__(self):
        self.executor = ToolExecutor()
        self._approval_gates: Dict[str, asyncio.Event] = {}
    
    async def execute_plan(
        self,
        pentest_id: str,
        case_id: str,
        plan: PentestPlan,
        evidence_base_path: Path,
    ) -> tuple[List[PentestTaskResult], List[PentestTaskResult]]:
        """
        Ejecuta plan secuencialmente.
        Si una tarea requiere aprobaciÃ³n, espera asyncio.Event.
        """
        
        completed = []
        failed = []
        
        for task in plan.tasks:
            try:
                # â³ Si requiere aprobaciÃ³n, esperar
                if task.requires_approval:
                    logger.info(f"â³ Esperando aprobaciÃ³n para {task.task_id}")
                    await self._wait_for_approval(pentest_id, task.task_id)
                
                # ðŸš€ Ejecutar tarea
                start_time = time.time()
                
                evidence_dir = evidence_base_path / task.phase.value
                evidence_dir.mkdir(parents=True, exist_ok=True)
                
                result = await self.executor.execute_sandboxed(
                    execution_id=task.task_id,
                    tool_id=task.tool,
                    command=task.command,
                    timeout=task.timeout,
                )
                
                duration = time.time() - start_time
                
                task_result = PentestTaskResult(
                    task_id=task.task_id,
                    tool=task.tool,
                    status="completed" if result.get("success", True) else "failed",
                    output=result.get("output", ""),
                    duration_seconds=duration,
                    artifacts=[str(evidence_dir)]
                )
                
                completed.append(task_result)
                logger.info(f"âœ… Ejecutada tarea {task.task_id} en {duration:.1f}s")
                
            except asyncio.TimeoutError:
                logger.error(f"âŒ Timeout en {task.task_id}")
                failed.append(PentestTaskResult(
                    task_id=task.task_id,
                    tool=task.tool,
                    status="failed",
                    error="TIMEOUT",
                ))
            
            except Exception as e:
                logger.error(f"âŒ Error ejecutando {task.task_id}: {e}")
                failed.append(PentestTaskResult(
                    task_id=task.task_id,
                    tool=task.tool,
                    status="failed",
                    error=str(e),
                ))
        
        return completed, failed
    
    async def _wait_for_approval(self, pentest_id: str, task_id: str, timeout: int = 3600):
        """Espera asyncio.Event para aprobaciÃ³n (timeout 1 hora)."""
        
        key = f"{pentest_id}:{task_id}"
        if key not in self._approval_gates:
            self._approval_gates[key] = asyncio.Event()
        
        gate = self._approval_gates[key]
        
        try:
            await asyncio.wait_for(gate.wait(), timeout=timeout)
            logger.info(f"âœ… AprobaciÃ³n recibida para {task_id}")
        except asyncio.TimeoutError:
            logger.warning(f"âŒ Timeout esperando aprobaciÃ³n para {task_id}")
            raise
    
    def approve_task(self, pentest_id: str, task_id: str):
        """Desbloquea aprobaciÃ³n de una tarea."""
        
        key = f"{pentest_id}:{task_id}"
        if key in self._approval_gates:
            self._approval_gates[key].set()
            logger.info(f"ðŸŸ¢ Desbloqueo de {task_id}")
        else:
            logger.warning(f"âš ï¸ Gate de aprobaciÃ³n no encontrado para {task_id}")


# Instancia global (usar en routes)
_executor_instance = PentestExecutor()


def get_executor() -> PentestExecutor:
    """Retorna instancia global del ejecutor."""
    return _executor_instance
